* MTG Engine
** Combat
Lets implement combat into the mtg engine. all the logic is in the mtg/ directory

Read mtg-Turn-structure.org in the combat phase to understand the steps.

- Write a function AvailableAttackers that returns a list of cards that can be declared as attackers. To be able to attack a card must be Active and not Tapped (see IsActive() function in mtg/core_engine/card.go). It must also be a creature card and currently in the player's battlefield zone.

- Declaring an attacker causes the attacking card to tap.

- AvailableActions() will need to be modified based on the phase/sub-phase that we're currently in (ex. only in the main phases can you play land or cast sorceries)

Write tests for this and add this functionality to cmd/mtg_test where players attack and block randomly.

** DONE Combat IsActive()

Bug: creatures are able to attack immediately after they're played, fix this bug

output generated by cmt/mtg_test/main.go
mtg game logic in mtg/

Creatures can only attack if IsActive() returns true (have to be untapped and not have summoning sickness)

ex of bug:

Turn 2 - Player 1 (Life: 6)
  Phase: Untap
  Phase: Upkeep
  Phase: Draw
    Drew a card
  Phase: Main1
    Available actions: [PlayLand Mountain#3 CastSpell Kird Ape#1 CastSpell Kird Ape#2 CastSpell Lightning Bolt#4 CastSpell Lightning Bolt#6 CastSpell Lightning Bolt#7 CastSpell Lightning Bolt#9 PassPriority]
    Casting Lightning Bolt#6 targeting Kird Ape#33
    Kird Ape#33 now at -2 life
    Available actions: [PlayLand Mountain#3 PassPriority]
    Playing Mountain#3
    Available actions: [CastSpell Kird Ape#1 CastSpell Kird Ape#2 CastSpell Lightning Bolt#4 CastSpell Lightning Bolt#7 CastSpell Lightning Bolt#9 PassPriority]
    Casting Kird Ape#1
  Phase: Combat
    Kird Ape#1 attacks




** DONE simple mtg
Write a command called mtg_test that plays a game of magic the gathering from the terminal and prints out the steps. I'd like it to print out who's turn it is and the current phase as the phases change. Players should have a deck of 30 cards a combination of lighting bolts and mountains.

the players should pick randomly from the list of available actions and then perform those actions (ex. cast spell or play land).

Players lives start at 9 each. Play until 1 player loses or any player has played more than 5 turns.

see mtg/ subdirectory for rules and game engine implementation. Also look at test files.


** DONE AvailableActions
write a function AvailableActions that returns a list of actions a player can take at the current state of the game. For example when it's a players main phase and they haven't played  a land that turn yet and they have land cards in their hand it should return 1 or more "Play  $LAND" actions (1 for each card in hand). See mtg/README.md for how the mtg rules engine works.

* TODO Publicity
- Monthly status updates
  - r/shandalar
  - shandalar discord
  - pig squad?
  - blog
- [[https://pigsquad.com/form-prge-2025][Retro Game Submission form]]
- [[https://pigsquad.com/form-prge-2025][Ebiten splash logo]]
* Overland
** Minimap
*** DONE City names
CLOSED: [2025-12-03 Wed 22:03]
Display a text box below the city icon with the name of the city. This will mean going through the tiles a 2nd time and then displaying the name. Use game/ui/elements/text.go to draw text
*** DONE Minimap sprites
In the MiniMap screen, assets.MiniMapTerrSpr_png (file assets/art/sprites/mini_map/Ttsprite.spr.png) contains 5 rows of images, each row has a different size.

The rows are
  - 13×13: 48 images (gems/diamonds in various colors)
  - 13×20: 6 images (taller UI elements)
  - 15×15: 1 image
  - 16×16: 10 images (medium sprites)
  - 23×23: 10 images (larger sprites)

Update game/ui/imageutil/loader.go LoadSpriteSheet() to allows the caller to specify an image size for each row. Or write a new function that is like LoadSpriteSheet() but takes image sizes as arguments.

Then update games/screens/minimap.go to use the new function to load assets.MiniMapTerrSpr_png and display the correct city

** TODO Coastlines (tile merge)
*** Overlay algorithm
I'm building a 2d isometric game that has a world you walk around in. That world can have different types of tiles (plains, forest, water, etc). These tiles are often grouped together in various shapes (ex. water tiles forming a lake or a river). I want you to describe an algorithm that could be used to detect transition points when the tiles change (ex. from a plains to a river tile) and suggest those connections.

Here's what I'm thinking:

For each tile, look at it's orthogonal neighbors and for each different type, note what type it is and what type of transition is needed. A transition could be required for a single edge or for multiple edges. Also, the type of transition may continue into the next neighbor so you would need to mark the transition as "open" vs "closed".

Ex.

W P1
W P2

Using P1 as the tile, you would need a W transition on the West side and because P2's West side is also W, the P2 transition South should be "open" so the transition can continue into P2.

Ex.

W P1
P P

In this example we P1 needs a W transition on the West side, but it should be closed to the South side.

This means the algorithm will only need to look at a tiles neighbors and neighbor's neighbors to decide what transition to make.

<><>
 <><>
*** Tile map
Build a tile map that describes how to join the transition sprites together.

Analyze the assets/art/sprites/world/land/Cstline1.spr.png file and look at the first 28 sprites (see cmd/tile_transitions). They should all be water sprites. Now find out which pieces connect together. You can do that by analyzing the lines of blue pixels on each of the corners. Ex. the first sprite has a blue edge that runs from 0,27 to 14,33 (could be off by a few pixels). That looks like it should match up with sprite in row 5 column 4, it has a blue edge that runs from 357,204 to 372,212.

Write a script that will find these edges that are similar and print them out. These are the pieces that can connect to each other.

Edges must be less that 50 (euclidean distance).

Also corners can only connect in certain ways. ex. 3->2 means starts at corner 3, edge is heading towards 2

| P1   | P2   |
|------+------|
| 3->2 | 0->1 |
| 1->2 | 0->3 |
| 2->1 | 3->0 |
| 1->0 | 2->3 |

Ok, lets simplify this. The tiles can only have an edge on a corner. The pixel points of each tile subimage corner are:

| Corner | Point (X,Y) |
|--------+-------------|
|      0 | 51,0        |
|      1 | 102,25      |
|      2 | 51,51       |
|      3 | 0,25        |

Edges can only be on the line between 1 corner and it's preceding and next corner. Ex from corner 0, edges can only be 0->1 or 0->3 an edge is not from 0->2. This should simplify edge finding a lot. Now instead of counting blue pixels you can count the number of non-transparent pixels.

For the tile at 0,0 in the sprite you should have 2 edges. 1 ~50 pixels long from 3->0 and 1 ~25 pixels long from 3->2.

For the third tile in the row, you should have 3 edges 1 ~25pixels long from 0->1, 1 ~50pixels long from 0->3 and 1 ~25 pixels long from 3->2.

*** Edge connections
Build a tile map that describes how to join the transition sprites together.

Analyze the assets/art/sprites/world/land/Cstline1.spr.png file and look at the first 28 sprites (see cmd/tile_transitions for sprite size). They should all be water sprites. Now find out which pieces connect together. You can do that by analyzing the lines of blue pixels on each of the corners. Ex. the first sprite has a blue edge that runs from 0,27 to 14,33 (could be off by a few pixels). That looks like it should match up with sprite in row 5 column 4, it has a blue edge that runs from 357,204 to 372,212.

Write a script that will find these edges that are similar and print them out. These are the pieces that can connect to each other.
*** Tile map with edge connections
Build a tile map that describes how to join the transition sprites together.

Cstline1.spr.png is a sprite image with 4 columns and 21 rows. For now we only care about the first 7 rows.

Look at cmd/tile_transition/edge_connections.txt to see how the tiles connect to each other. We need to store that info as a tile map that can be used by the game to build tile transitions between land tiles in the game.

We also need to identify the full-length edges. These will be used to place them correctly against the tile type (ex. the first 28 images are water transitions, so we want the long edge to be up against a water tile)

See cmd/tile_transitions/analyze_edges.py for how to identiy edges. It currently is set to look for connection edges (ednges < 40). Now we want to find edges that are at least 40

Suggest a tile map format that can be used to store this metadata about transition tiles.

*** Overview
Write a separate program that will generate a smaller world and overlay the transition tiles. I want to see some examples of tile transitions.

Each tiles has four corners in a diamond shape, starting from the top 0-3 representing N,E,S,W directions. When different tile types meet (ex. Plains/Forest) there is an additional threshold tile added. These are the Cstline_png and Cstline2_png sprites.
*** Cstline sprites
CstlineMap_txt is 7 rows with 4 columns per row. Cstline1_png has 3 sets of tiles, 1 for Water, Marsh and Forest tiles. Cstline2_png has 2 sets of tiles: Sand and Ice.

Each set of tiles is the same, just for different types of terrain.

*** Cstline Map format
The map file CstlineMap_txt describes what corners the threshold merges. There are 4 images per line and are separate by the '|' character in the map file.

Ex:

0,1|0,3 means there are 2 images, the first covers the 0,1 corners and the second covers the 0,3 corners.

*** Overlay algorithm
After placing tiles when generating the world, go back through the map and for each tile look at the surrounding tiles. If there is a change from one type to another, add a threshold tile overlay to visually transition the tiles.

Ex:

legend: (W = Water, P = Plains)

Tiles are offset because they're diamond shaped

W W P1
 W P2

Each tile requires 2 transition pieces to complete the length of the tile.

P1 has 2 transition pieces T1 and T2. Both have only a single full edge from 0->3 or 3->0. T1 must have T2 in it's list of connect edges.

T1's 0 corner starts at P1's 0 corner. T2's 0 corner starts halfway between P1 0 and 3 corner.

P2 has 2 transition pieces T3 and T4. Both have a single full edge from 0->3 or 3->0. T2 must have T3 in it's list of connect edges and T3 must have T4 in it's list of connect edges. T3's 0 corner starts at P2's 0 corner. T4's 0 corner starts halfway between P2's 0 and 3 corner.

Read Cstline_map.json to see the map of tiles. the map defines a set of transitions. Each tile type (Water, Forest, Marsh, Sand, Ice) has the same set of transitions, just styled to match the tile type. The full tileset is 28 tiles (7 rows, 4 cols). Cstline1.spr.png has (in order) Water, Marsh and Forest. Cstline2.spr.png has Sand and Ice.

To start build a map of the above example tile layout and write a solution that only places the water transitions.

Modify cmd/tile_transitions to do this.

TRANSITION_CORNER_POSITIONS = {
    0: (51, 0),  # Top
    1: (101, 25),  # Right
    2: (51, 51),  # Bottom
    3: (0, 25),  # Left
}

TILE_CORNER_POSITIONS = {
    0: (103,0),
    1: (205,50),
    2: (103,100),
    3: (0, 50)
}

# Valid edge directions (corner -> adjacent corner, both directions)
EDGE_DIRECTIONS = [
    (0, 1),  # Top to Right
    (1, 0),  # Right to Top
    (1, 2),  # Right to Bottom
    (2, 1),  # Bottom to Right
    (2, 3),  # Bottom to Left
    (3, 2),  # Left to Bottom
    (3, 0),  # Left to Top
    (0, 3),  # Top to Left
]






* DONE Deck/Collection Refactor
I want to refactor how decks and card collections are managed. Currently a player has a card collection but all Characters have a deck. Characters consist of the player and rogues (enemies).

Instead of player having a collection, characters should have a card collection, where each collection item has additional metadata showing which deck a card is part of. A player can have multiple decks, but enemies only have a single deck.

type CollectionItem struct {
 Card
 Count int  - number of cards in the collection
 DeckCounts []int - index of deck that has the count of the Card in the deck
}

To determine if a card is in a deck you have to iterate over the list of collectionitems. When a player loses a duel, it decrements the cards Count and iterates over DeckCounts and sets the value in each array to the min of Count and the value of DeckCounts.

Instead of "Sideboard" cards, rogues will now have all their cards in their "collection". By default all cards (DeckRaw and SideboardRaw) and the Rogue will only have a single deck. It will contain all cards listed in DeckRaw, but not in SideboardRaw.




* Card Art
** Smaller card art
Card art is 150px wide
- drawing text onto card frame would make it clearer as it's scaled up

- Magnified size is 250-300px wide
- Using blank-card.png would make card art 236px wide

Modify download_card_images.py to use the

** DONE WASM card art
CLOSED: [2025-12-05 Fri 17:03]
Is there a way to tell if my game is running in wasm/browser vs on a regular OS? If so, I'd like to modify the CardImage() function to make https requests to https://throwingbones.com/ben/cardimages.zip instead of reading it from the embedded file system.

Write a package that can read a zip file over http that uses the range operator to download the zip file directory and then download the individual file in the compressed .zip file using the range operator.

Cache the directory in memory so it doesn't require re-requesting the zip file directory.

The library zip reader will reread the directory when opening a file (see `findBodyOffset()`). Instead make a custom version of `findBodyOffset` and `Open()` that use a local copy of the zip file directory.

See game/utils/httpzip/reader.go for a partial implementation





* Starting screens
* TODO Saving the game
Come up with a way to save the game state. You'll want to save the generated world (tiles and cities), the location of all current enements and the player object. Then implement a save function and write some tests.
* DONE Antigravity CLI
User provides prompt file and worktree name

Write a script that will perform the same steps as the new Google AntiGravity editor.

agcli.py
--prompt -p   Prompt filename
--worktree -w Name of git worktree to create

The script itself should do the following steps:

- Make git worktree
- change to worktree directory
- Write an implementation plan based on prompt [claude_yolo.sh]
- Write code based on plan [claude_yolo.sh]
- Run tests [claude_yolo.sh]
- Do code review [claude_yolo.sh]
- Make suggested changes [claude_yolo.sh]
- Commit changes [claude_yolo?]

For each step that requires claude_yolo.sh - write a prompt that will for the action. These prompts will be embedded into the script itself so the user can change them if needed.

claude_yolo.sh - a version of claude code that runs in a container and doesn't prompt for user input.


** DONE AGCLI notes
- make test fails because it can't compile
       /usr/local/go/pkg/tool/linux_amd64/link: running gcc failed: exit status 1
     /usr/bin/gcc -m64 -s -o $WORK/b272/httpzip.test -rdynamic /tmp/go-link-3891896473/go.o
     /tmp/go-link-3891896473/000000.o /tmp/go-link-3891896473/000001.o
     /tmp/go-link-3891896473/000002.o /tmp/go-link-3891896473/000003.o
     /tmp/go-link-3891896473/000004.o /tmp/go-link-3891896473/000005.o
     /tmp/go-link-3891896473/000006.o /tmp/go-link-3891896473/000007.o
     /tmp/go-link-3891896473/000008.o /tmp/go-link-3891896473/000009.o
     /tmp/go-link-3891896473/000010.o /tmp/go-link-3891896473/000011.o
     /tmp/go-link-3891896473/000012.o /tmp/go-link-3891896473/000013.o
     /tmp/go-link-3891896473/000014.o /tmp/go-link-3891896473/000015.o
     /tmp/go-link-3891896473/000016.o /tmp/go-link-3891896473/000017.o
     /tmp/go-link-3891896473/000018.o /tmp/go-link-3891896473/000019.o -O2 -g -lresolv -O2 -g
     -lpthread
     /usr/bin/ld: cannot find /lib/x86_64-linux-gnu/libc.so.6: No such file or directory
     collect2: error: ld returned 1 exit status

- go build fails becuase cardimages.zip can't be found
       assets/cardimages_native.go:9:13: pattern art/cardimages.zip: no matching files found

- gofmt works

- git command failure:

  Bash(git add game/screens/edit_deck.go game/ui/elements/scrollable_list.go
      .agcli/IMPLEMENTATION_PLAN.md)
  -> Error: fatal: pathspec 'game/screens/edit_deck.go' did not match any files


- failure message: Error: fatal: pathspec 'game/screens/edit_deck.go' did not match any files

* Amulets
** DONE Initial Framework
Implement colored amulets. These are amulets the player can collect either by fighting enemies or completing quests in a town. There is one amulet for each color of magic (Red, White, Blue, Green and Black). Each city/town has an amulet color associated with it. This will affect other aspects of the game, so store the city color when creating a new city.
** DONE Amulets on world_frame
CLOSED: [2025-12-03 Wed 22:03]
Display amulets on the world_frame screen. Add Amsprite.spr.png to assets/embed.go and use that to display the amulets. The colors in the sprite are (in order):
- White
- Blue
- Black
- Red
- Green

Display them in the world frame at 125,628 and 250,628 and 375,628 and 500,628 and 625,628. Immediately next to the image of the amulet display the player's count of that color of amulet, similar to how gold and food count are displayed.

* UI
** DONE UI click and drag
How would I implement a click-and-drag function? In edit_deck.go I'd like to be able click and drag cards to/from the player's deck area.

Seems like I need a "droppable areas" where draggable objects can be dropped?

Also, need to be able to designate things as "draggable". Then when the left button is clicked and held the draggable item should follow the mouse cursor.

Add a new UI effect that can designate an element as draggable and another effect that implements droppable. Maybe this can be done through an interface?

Make the items in the scrollable list "draggable"

* World magics
** DONE Initial Framework
Cities have 3 tiers:

1. Hamlet
2. Town
3. Capital

Update game/domain/city.go to use a enum for the tiers and update all calls to city tier to use the enum.

World magics
------------

Each world magic is assigned to a random Capital (tier 3) city as the world is being generated. A player can buy the world magic at the city that has that world magic. Also, the world magics a player has purchased should be tracked on the player object.

List of world magics and gold cost:

- Sword of Resistance - 400
- Quickening - 300
- Leap of Fate - 300
- Ring of the Guardian - 500
- Haggler's Coin - 250
- Tome of Enlightenment - 300
- Sleight of Hand - 300
- Staff of Thunder - 100
- Conjurer's Will - 300
- Dwarven Pick - 125
- Amulet of Swampwalk - 125
- Fruit of Sustenance - 50
* TODO enemy difficulty scaling
-   after completing a dungeon
-   after buying a world magic
-   after defeating a Planeswalker

* TODO card wins/sales
- After defeating an enemy select cards based on rarity. Common and uncommon cards should be given as rewards more often and rare cards should be less frequent. Reserved cards (Black Lotus, Moxen, etc) should never be given as rewards.

* TODO dungeons
-   make harder, fix life loss bug
-   magic/chess puzzles? (Ex win this turn)

* TODO challenges
-   no reserved cards
-   game loss is permadeath (hardcore mode)
-   increased enemy strength (life, starting cards, etc)

* TODO Quests
- mana link
- free card
- amulet
- quest timer
- destination city

When the player is in a city and talks to the wiseman, sometimes he can give the player quests. The reward is known at the time the quest is shown and the player can refuse the quest. A player can only have 1 active quest at a time.

These quests are one of several types:
- Go to a nearby city (Deliver a Letter or other task)
  - Rewards: Mana Link (player life total goes up by 1. Once a city has been linked, it can't be linked again unless it has been unlinked by an enemy)
  - Rewards: Amulet - 1-3 amulets of that cities amulet color
  - Rewards: free card - the player is given a card that includes that cities amulet color
- Defeat an enemy - Wiseman says something like "A Goblin Warlord has been menacing our village"
  - Rewards: Mana Link (player life total goes up by 1. Once a city has been linked, it can't be linked again unless it has been unlinked by an enemy)
  - Rewards: Amulet - 1-3 amulets of that cities amulet color
  - Rewards: free card - the player is shown a list of cards that include that cities amulet color and can choose one of them

Each quest has a "quest timer" and if not completed in that time, that city will no longer give the player new quests.

see game/domain/city.go for city details and game/domain/player.go for player details

see also assets/text/Advstrings.txt for some sample text for quests (@QUESTSTATUS). Modify as needed.

* TODO Random Encounters
While walking around the overland (see game/world/level.go) there are random encounters the player can interact with. The sprites for them are in assets/art/sprites/world/land/Locatn07.spr.png, similar to Cities1_png, but is 5 cols 2 rows, with the 2nd row being the ground/shadows.

These encounters should appear on a tile as the player walks around the world, similar to how enemies spawn, but less frequently than enemies.

Once a player touches the encounter take them to a new screen that just says "Random Encounter" and the player can press Escape key to exit.

Build the random encounters logic drawing/updating (in a file named random_encounters.go) and build the default random encounter screen (in game/screens/).

After a player leaves the random encounter, it is removed from the map and can't be revisited.
* TODO Wiseman
** DONE [prompt] Wiseman Tales
On the city screen a player can click on "Begin Quest" to talk to the sage of the city. Go to a new screen that with the Wiseman_png image (in embed.go) as the backgroud (no border, scale wiseman image to screen size (1024x768)). Use the assets/text/Advblocks.txt file to display the story the wiseman has to tell.

Display the text in the rectangle {0,0} to {290, 768}. If the text is too large to fit in that rectangle add ellipses and use click/touch/spacebar to advance to the next block of text.

At the final line, pressing click/touch/spacebar takes you back to the city screen.

Use the Just functions (JustPressed, etc) to make sure it doesn't accidentally scroll 2 screens at once.

* DONE Duel/Ante Screen
CLOSED: [2026-01-02 Fri 20:52]
Initial version will allow player to bride or "play game". If play game is chosen, randomly determine winner and give wins/losses.

- [X] Clean up Rogue/Enemy refactor
- [X] Implement bribes (static 20 gold)
- [X] Implement duel (75% chance of winning, win 3 cards or lose ante)
- [X] show winning screen
- [X] show losing screen
- [X] Give player starting deck
- [X] Add enemy "level" to .toml files (determines life and bribe cost) [[https://mtg.wiki/page/Magic%3A_The_Gathering_%28MicroProse%29_Preconstructed_Decks?utm_source=chatgpt.com][wiki-src]]
- [X] Add color for each enemy (to choose background)
  - or do it at runtime by counting cards/mana symbols

| Tier              | Enemy Name            | Bribe |     Life |
|-------------------+-----------------------+-------+----------|
| Weak              | Cleric                |    40 |       10 |
| Weak              | Seer                  |    40 |       10 |
| Weak              | Witch                 |    40 |       10 |
| Weak              | Sorceress             |    40 |       10 |
| Weak              | Druid                 |    40 |       10 |
| Aggro             | Priestess             |    40 |       12 |
| Aggro             | Merfolk Shaman        |    40 |       12 |
| Aggro             | Undead Knight         |    40 |       12 |
| Aggro             | Sorcerer              |    40 |       12 |
| Aggro             | Elvish Magi           |    40 |       12 |
| Typical           | Crusader              |    60 |       14 |
| Typical           | Conjurer              |    60 |       14 |
| Typical           | Warlock               |    60 |       14 |
| Typical           | Troll Shaman          |    60 |       14 |
| Typical           | Enchantress           |    60 |       14 |
| Two-color Lesser  | Tusk Guardian         |    70 |       16 |
| Two-color Lesser  | Mind Stealer          |    70 |       16 |
| Two-color Lesser  | Sedge Beast           |    70 |       16 |
| Two-color Lesser  | Elementalist          |    70 |       16 |
| Two-color Lesser  | Fungus Master         |    70 |       16 |
| Intermediate      | Paladin               |    80 |       18 |
| Intermediate      | Sea Dragon            |    80 |       18 |
| Intermediate      | Vampire Lord          |    80 |       18 |
| Intermediate      | Goblin Lord           |    80 |       18 |
| Intermediate      | Forest Dragon         |    80 |       18 |
| Genies            | Saltrem Tor           |    80 |       19 |
| Genies            | Aga Galneer           |    80 |       19 |
| Genies            | Queltosh              |    80 |       19 |
| Genies            | Alt-a-Kesh            |    80 |       19 |
| Two-color Greater | Lord of Fate          |   100 |       20 |
| Two-color Greater | Winged Stallion       |   100 |       20 |
| Two-color Greater | Centaur Shaman        |   100 |       20 |
| Two-color Greater | Centaur Warchief      |   100 |       20 |
| Two-color Greater | Ape Lord              |   100 |       20 |
| Strong            | Archangel             |   100 |       22 |
| Strong            | Shapeshifter          |   100 |       22 |
| Strong            | Nether Fiend          |   100 |       22 |
| Strong            | Hydra                 |   100 |       22 |
| Strong            | Beastmaster           |   100 |       22 |
| Dragons           | Kiska-Ra              |   110 |       24 |
| Dragons           | Whim                  |   110 |       24 |
| Dragons           | Mandurang             |   110 |       24 |
| Dragons           | Dracur                |   110 |       24 |
| Dragons           | Prismat               |   110 |       24 |
| Henchmen          | High Priest           |     - | Up to 27 |
| Henchmen          | Thought Invoker       |     - | Up to 27 |
| Henchmen          | Necromancer           |     - | Up to 27 |
| Henchmen          | War Mage              |     - | Up to 27 |
| Henchmen          | Summoner              |     - | Up to 27 |
| Guildlords        | Sainted One           |     - |    35-45 |
| Guildlords        | Astral Visionary      |     - |    35-45 |
| Guildlords        | Greater Lich (Azaar)  |     - |    35-45 |
| Guildlords        | Dragon Lord (Kzzy'n)  |     - |    35-45 |
| Guildlords        | Great Druid (Morgane) |     - |    35-45 |
| Final Boss        | Arzakon               |     - |      400 |

* TODO Edit deck screen
Major UI elements needed:
- [X] scrollable bottom section, always scroll by 1 full card?
- [X] card hover
- [X] deck layout
- selecting buttons to filter library
- search box for filtering library
- drag-and-drop cards into/out of deck
- right-click to sell? Or multi-select then sell button?
- deck group by card

- [X] card image for art/name only


- [ ] Show cards
- [ ] Sell cards
- [ ] Add Decks to player, including active deck

** DONE Card collections limits
CLOSED: [2026-01-04 Sun 10:19]
The list of cards in the card collection is affected by cards in the active deck. Cards in the active deck shouldn't show up in the collection list unless there are more cards in the collection than in the deck (ex. there are 13 mountains in the collection, but only 8 of them are in the deck. The mountain card should show up in the collection list, but with a count of 5 instead of 13 (13 - 8)).

When the last card in a collection list is added to a deck, it should be removed from the collection list.
** TODO Selling cards
When you're in a town you can sell cards. Sale price is default 50% of the buy price. 60% at tier 2 cities and 75% at tier 3 cities (capitals). All cities have an amulet color and if the color identify of the card includes that amulet color it increases the price an additional 10%.

Add a function in the Card object that accepts a City as an argument and returns the sale price.

Then in the deck editor if you hover over a card, pressing the S key will sell the card. Also, when hovering over a card display the sales price above the card magnifier.


** DONE Edit Deck card counts in collection screen
CLOSED: [2026-01-02 Fri 20:37]
In Deck Edit screen add card counts to the collection, similar to how it works in the deck edit area.
** Magnify in deck list
Hovering over a card in the deck area should trigger the magnifier.
** Deck Layout
In the draggable section of edit_deck.go I also want to display the player's deck. Use the card art images for the cards and display them in there. Also if there are multiples of the same cards only show a single card, but add teh count to the lower right hand corner of the card.

Group the cards by name, even if they're different printings (ex. group all mountain cards together).

Also the draggable area should be the rectangle (x,y) and should be call the deck area:
 300x0 - 1024x588


* TODO player decks/card collections
- [ ] constraints on a player's deck
  - should only allow cards in a player's collection (can check when adding a card to a deck)
  - selling a card/losing a card to ante should remove the card from the card collection and all player decks
* [X] Make more enemies appear and move randomly
Every 30 ticks if a player hasn't interacted with an enemy in the last 100 ticks spawn a new enemy.

Also, make the enemies have a little movement jitter towards the player instead of running directly at the player. Also, make the enemies occasionally stop and wait until the player gets closer and then run towards them.

* Storing Large files/images?
Should I store card art in the repo?
- No, this bloats the repo. Instead have tools to download images from scryfall as needed.

Options:
- Store individual card art on a server in the format and compression I want. Make http requests when loading art.
  - Con: Now I'm responsible for keeping carddart up or the game breaks.
  - Con: Could make calls to scryfall directly, but again it requires some server to stay running and a way to get card URLs
- Store full zip files.
  - Could be in embed.FS
    - Con: 2GB file limit for binaries
    - Con: large filesize makes download slow
  - Could be distributed with game, like .WAD files for doom/quake
    - Pro: people can distribute their own .zip files with their mods for custom card lists
    - Con: Doesn't work with web version, there is no .zip file to reference

* Card Art
Image art should be 190x150
card back images are 228 x 325

Would also require text for:
- mana cost
- set symbol
- card text
- flavor text


I've opted out of writing a cat decoder since I can get card art online: https://scryfall.com/docs/api/images

** Sizes
Medart.cat is 31MB

That's 300 cards at 100k/card, which seems possible.
- burgeoning.jpg is 160k
- burgeoning-art.jpg is 130k

Try converting them to .png and running:
- pngquant --quality=60-80

Example art image for burgeoning, size is 190x140

-rw-r--r--  1 ben ben  59K Jul 23 23:19  c16-143-burgeoning-art.png
-rw-rw-r--  1 ben ben  25K Jul 23 23:20  c16-143-burgeoning-art-fs8.png

stripped down is 25k! That's pretty good! For all 25k cards, that's only 625MB

For 1k cards that's only 25MB, much better than Medart! It could be even better if I could separate the palette from the image, but .png doesn't support that and ChatGPT doesn't give me any good standard image formats that do this.

Google suggest GIF format, LZW compressed and can have separate palette

Also look into AVIF format (https://en.wikipedia.org/wiki/AVIF)

*** Resizing images:
# Resize to specific width, height auto-calculated
convert input.png -resize 300x output.png

# Resize to specific height, width auto-calculated
convert input.png -resize x200 output.png

# Resize to fit within 300x200 box (won't exceed either dimension)
convert input.png -resize 300x200 output.png

# Resize by percentage
convert input.png -resize 50% output.png
* Storing cards
Can use MTG Oracle ID for card id, and keep updated with scryfall

- images: https://scryfall.com/docs/api/images
- cards.json: https://scryfall.com/docs/api/bulk-data

* Adding transparency to an image
Converted buttons that had black background to transparent background:

convert assets/art/sprites/city/Smbuybttn.png -transparent black assets/art/sprites/city/Smbuybttn.png

* Scaling the game screen
Note: why does web version scale up?

Some options for handling scaling

## 1. **Percentage-Based Positioning**
Instead of hardcoded pixel positions, use percentages of screen dimensions:

```go
// Instead of:
buttonX := 100
buttonY := 50

// Use:
buttonX := int(float64(screenW) * 0.1)  // 10% from left
buttonY := int(float64(screenH) * 0.065) // 6.5% from top
```

## 2. **Anchor-Based Layout System**
Create an anchor system for UI elements:

```go
type Anchor int
const (
    TopLeft Anchor = iota
    TopCenter
    TopRight
    CenterLeft
    Center
    CenterRight
    BottomLeft
    BottomCenter
    BottomRight
)

type UIElement struct {
    Anchor Anchor
    OffsetX, OffsetY int  // Offset from anchor point
}

func (ui *UIElement) GetPosition(screenW, screenH int) (int, int) {
    switch ui.Anchor {
    case TopLeft:
        return ui.OffsetX, ui.OffsetY
    case TopCenter:
        return screenW/2 + ui.OffsetX, ui.OffsetY
    case Center:
        return screenW/2 + ui.OffsetX, screenH/2 + ui.OffsetY
    // ... other cases
    }
}
```

## 3. **Responsive Layout Manager**
Create a layout manager that handles different screen sizes:

```go
type LayoutManager struct {
    baseWidth, baseHeight int  // Your original 1024x768
}

func (lm *LayoutManager) ScalePosition(x, y, currentW, currentH int) (int, int) {
    scaleX := float64(currentW) / float64(lm.baseWidth)
    scaleY := float64(currentH) / float64(lm.baseHeight)

    return int(float64(x) * scaleX), int(float64(y) * scaleY)
}
```

## 4. **Constraint-Based Layout**
Define relationships between UI elements:

```go
type Constraint struct {
    Element    *UIElement
    RelativeTo *UIElement  // nil for screen edges
    Spacing    int
    Direction  Direction   // Above, Below, LeftOf, RightOf
}
```

## 5. **Grid System**
Divide the screen into a grid and position elements within grid cells:

```go
type GridLayout struct {
    Rows, Cols int
}

func (g *GridLayout) GetCellPosition(row, col, screenW, screenH int) (int, int) {
    cellW := screenW / g.Cols
    cellH := screenH / g.Rows
    return col * cellW, row * cellH
}
```

## **Recommended Approach for Your Game:**

Given your current setup, I'd suggest starting with **option #2 (Anchor-Based)** combined with **option #3 (Layout Manager)**:

1. **Modify your Button struct** to include anchor information
2. **Update your screen classes** (CityScreen, BuyCardsScreen, etc.) to use anchored positioning
3. **Create a helper function** that converts your current hardcoded positions to anchored ones

This approach:
- Requires minimal changes to existing code
- Provides good flexibility for different screen sizes
- Is easy to understand and maintain
- Works well with your existing UI element structure

Would you like me to show you how to implement the anchor-based system for your specific button and UI setup?
Tokens: 9.8k sent, 738 received. Cost: $0.04 message, $0.17 session.

game/game.go
game/world/level.go
architect> /ask I'd like some abstract representation of pixels that I can use so that I don't have to pass scale around everywhere, what would that look like? and what are the shortcomings of that approach?

Here's an abstract pixel representation approach:

## **Virtual Pixel System**

```go
// Virtual pixel unit - always represents the same logical size
type VPixel int
type VPoint struct {
    X, Y VPixel
}
type VRect struct {
    X, Y, W, H VPixel
}

// Global viewport that handles conversion
type Viewport struct {
    baseWidth, baseHeight int     // Your reference resolution (1024x768)
    currentWidth, currentHeight int
    scale float64
}

var GlobalViewport *Viewport

func (vp *Viewport) ToScreen(v VPixel) int {
    return int(float64(v) * vp.scale)
}

func (vp *Viewport) ToScreenPoint(p VPoint) (int, int) {
    return vp.ToScreen(p.X), vp.ToScreen(p.Y)
}

func (vp *Viewport) FromScreen(pixels int) VPixel {
    return VPixel(float64(pixels) / vp.scale)
}

func (vp *Viewport) UpdateScale(newWidth, newHeight int) {
    vp.currentWidth = newWidth
    vp.currentHeight = newHeight
    vp.scale = math.Min(
        float64(newWidth)/float64(vp.baseWidth),
        float64(newHeight)/float64(vp.baseHeight),
    )
}
```

## **Usage Example**

```go
// Instead of:
buttonX := 100
buttonY := 50

// Use:
buttonPos := VPoint{X: 100, Y: 50}

// In your draw function:
screenX, screenY := GlobalViewport.ToScreenPoint(buttonPos)
drawButton(screen, screenX, screenY)
```

## **Integration with Your Button System**

```go
type Button struct {
    // ... existing fields
    Position VPoint  // Instead of X, Y int
    Size     VPoint  // Instead of separate width/height
}

func (b *Button) Draw(screen *ebiten.Image) {
    x, y := GlobalViewport.ToScreenPoint(b.Position)
    w, h := GlobalViewport.ToScreenPoint(b.Size)

    opts := &ebiten.DrawImageOptions{}
    opts.GeoM.Scale(GlobalViewport.scale, GlobalViewport.scale)
    opts.GeoM.Translate(float64(x), float64(y))
    screen.DrawImage(b.Normal, opts)
}
```

## **Shortcomings of This Approach**

### **1. Global State Dependency**
- Creates coupling between all UI code and the global viewport
- Makes testing harder (need to initialize global state)
- Can cause issues in multi-threaded scenarios

### **2. Type Safety Issues**
- Easy to accidentally mix VPixel and regular int values
- Compiler won't catch when you forget to convert
- Can lead to subtle bugs when values get passed around

### **3. Performance Overhead**
- Every pixel access requires a multiplication
- Frequent conversions can add up, especially for complex UI
- Cache misses from extra indirection

### **4. Debugging Complexity**
- Harder to debug layout issues (need to convert values mentally)
- Print statements show virtual pixels, not actual screen positions
- Tools/debuggers show actual pixels, creating disconnect

### **5. Third-Party Library Integration**
- Ebiten and other libraries expect real pixels
- Need conversion at every boundary
- Easy to forget conversions when using library functions

### **6. Precision Loss**
- Repeated conversions can accumulate floating-point errors
- Small VPixel values might round to 0 at small scales
- Can cause alignment issues with fractional scaling

## **Alternative: Context-Based Approach**

```go
type RenderContext struct {
    scale float64
    screenW, screenH int
}

func (rc *RenderContext) ScaleX(x int) int {
    return int(float64(x) * rc.scale)
}

// Pass context explicitly instead of global state
func (b *Button) Draw(screen *ebiten.Image, ctx *RenderContext) {
    x := ctx.ScaleX(b.X)
    y := ctx.ScaleY(b.Y)
    // ...
}
```

This avoids global state but requires passing the context around, which you wanted to avoid.

## **Recommendation**

For your game, I'd suggest a **hybrid approach**:
- Use the virtual pixel system for **UI layout and positioning**
- Keep the global viewport for convenience
- Add helper methods to your existing structs to handle conversion
- Use real pixels for performance-critical rendering code

This gives you the convenience without the full overhead everywhere.
Tokens: 12k sent, 937 received. Cost: $0.05 message, $0.22 session.
